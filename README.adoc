= Cbject
:toc: preamble
:sectnums:

OOP framework for C

https://github.com/alexmarincu/Cbject/actions/workflows/ci.yml[image:https://github.com/alexmarincu/Cbject/actions/workflows/ci.yml/badge.svg[CI]] https://github.com/alexmarincu/Cbject/releases[image:https://img.shields.io/github/v/release/alexmarincu/Cbject?include_prereleases[GitHub release (latest by date including pre-releases)]] https://github.com/alexmarincu/Cbject/blob/master/LICENSE[image:https://img.shields.io/github/license/alexmarincu/Cbject[GitHub]]

== Introduction
Cbject makes it easier to write object oriented code in C.

.Features
* Classes
* Abstract classes
* Virtual functions
* Singletons
* Encapsulation
* Single inheritance
* Polymorphism

.Roadmap
* Interfaces
* Multiple inheritance with interfaces
* Example projects

== Basic syntax
All files must include Cbject.h and must start with the following define:
[source,c]
----
#undef Type
#define Type <NewTypeName>
----

=== Abstract Classes
Abstract classes are declared and defined with the following macros:
[source,c]
----
AbstractClass(superClass, paramsPack, dataPack, virtFunsPack, funsPack)
AbstractClassSetup(superClass, virtFunSetup, funOverrideSetupPack)
----

Example:

.In the .h file
[source,c]
----
#undef Type
#define Type Shape

AbstractClass(
    NA,
    Params(Point origin),
    Data(
        ((Point, origin), Public)),
    VirtFuns(
        ((float, area, NA), Pure),
        ((void, draw, NA), Impl)),
    NA);
----

.In the .c file
[source,c]
----
#undef Type
#define Type Shape

AbstractClassSetup(
    NA,
    VirtFunSetup(
        ((float, area, NA), NA),
        ((void, draw, NA), NA)),
    FunOverrideSetup(
        ((void, draw, NA), Shape)));
----

All needed boilerplate code like constructors, destructors, virtual function calls, function binding and others are generated from the setup macro.

=== Classes
Classes are declared and defined with the following macros:
[source,c]
----
Class(superClass, paramsPack, dataPack, virtFunsPack, funsPack)
ClassSetup(superClass, virtFunSetup, funOverrideSetupPack)
----

Example:

.In the .h file
[source,c]
----
#undef Type
#define Type Rectangle

Class(
    Extends(Shape),
    Params(Point origin, uint32 width, uint32 height),
    Data(
        ((uint32, width), Public),
        ((uint32, height), Public)),
    NA,
    Funs(
        ((void, makeSquare, Params(uint32 const edgeSize)), Final),
        ((float, area, NA), Override)));
----

.In the .c file
[source,c]
----
#undef Type
#define Type Rectangle

ClassSetup(
    Extends(Shape),
    NA,
    FunOverrideSetup(
        ((float, area, NA), Shape)));
----

All needed boilerplate code like constructors, destructors, virtual function calls, function binding and others are generated from the setup macro.

=== Singletons
Singletons are declared and defined with the following macros:
[source,c]
----
Singleton(superClass, dataPack, funsPack)
SingletonSetup(superClass, funOverrideSetupPack)
----

Example:

.In the .h file
[source,c]
----
#undef Type
#define Type Application

Singleton(
    NA,
    Data(
        ((Circle *, circle), Private),
        ((Rectangle *, rectangle), Private),
        ((Rectangle *, heapRectangle), Private),
        ((ColoredCircle *, coloredCircle), Private)),
    Funs(
        ((void, start, NA), Final)));
----

.In the .c file
[source,c]
----
#undef Type
#define Type Application

SingletonSetup(
    NA,
    NA);
----

All needed boilerplate code like the instance getter, function binding and others are generated from the setup macro.

=== Init and Terminate functions
For all classes the Init and Terminate functions need to be defined. Data members can be initialized by using the constructor params in the Init section and any needed cleanup can be made in the Terminate section.

Example:

.In the .c file
[source,c]
----
#undef Type
#define Type Shape

AbstractClassSetup(...);

Init { me->data.origin = params->origin; }
Terminate {}
----

[source,c]
----
#undef Type
#define Type Rectangle

ClassSetup(...);

Init
{
    Shape_init(Cast(me, Shape), &(ShapeParams){params->origin});
    me->data.width = params->width;
    me->data.height = params->height;
}

Terminate {}
----

=== Setters and Getters
Setters and Getters can be defined with default implementation or can be customized.

.Default setter and getter
[source,c]
----
SetterImpl(uint32, height);
GetterImpl(uint32, height);
----

.Custom setter
[source,c]
----
Setter(uint32, width)
{
    if (width < 100)
    {
        me->data.width = width;
    }
}
----

=== Functions and overriding functions
Functions are defined with the following macro:
[source,c]
----
Fun(funReturnType, funName, funParamsPack)
----

The funParamsPack argument is declared with Params(<list of params>) or NA if no params are given.

Example:

.Normal function
[source,c]
----
Fun(void, makeSquare, Params(uint32 const edgeSize))
{
    me->data.height = edgeSize;
    me->data.width = edgeSize;
}
----

.Function override
[source,c]
----
FunOverride(float, area, NA) { return me->data.width * me->data.height; }
----

=== To be continued...